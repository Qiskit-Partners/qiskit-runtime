{
  "name": "qaoa",
  "description": "Qiskit Runtime QAOA program",
  "max_execution_time": 18000,
  "spec": {
    "parameters": {
      "$schema": "https://json-schema.org/draft/2019-09/schema",
      "properties": {
        "operator": {
          "description": "The cost Hamiltonian, consisting of Pauli I and Z operators, whose smallest eigenvalue we're trying to find.",
          "type": "PauliSumOp"
        },
        "optimizer": {
          "description": "The classical optimizer used to update the parameters in each iteration. Per default, SPSA with automatic calibration of the learning rate is used.",
          "type": "qiskit.algorithms.optimizers.Optimizer"
        },
        "initial_point": {
          "description": "Initial parameters of the ansatz. Can be an array or the string ``'random'`` to choose random initial parameters.",
          "type": "Union[numpy.ndarray, str]"
        },
        "aux_operators": {
        "description": "A list of operators to be evaluated at the final, optimized state.",
        "type": "List[PauliSumOp]"
        },
        "reps": {
          "description": "The number of QAOA repetitions, i.e. the QAOA depth typically labeled p. This value defaults to 1.",
          "type": "int"
        },
        "shots": {
          "description": "The number of shots used for each circuit evaluation. Defaults to 1024.",
          "type": "int"
        },
        "alpha": {
          "description": "The fraction of top measurement samples to be used for the expectation value (CVaR expectation). Defaults to 1, i.e. using all samples to construct the expectation value.",
          "type": "float"
        },
        "measurement_error_mitigation": {
          "description": "Whether to apply measurement error mitigation in form of a tensored measurement fitter to the measurements. Defaults to False.",
          "type": "bool"
        },
        "use_swap_strategies": {
          "description": "A boolean on whether or not to use swap strategies when transpiling. If this is False then the standard transpiler with the given optimization level will run.",
          "type": "bool"
        },
        "use_pulse_efficient": {
          "description": "A boolean on whether or not to use a pulse-efficient transpilation. This flag is set to False by default.",
          "type": "bool"
        },
        "optimization_level": {
          "description": "The optimization level to run if the swap strategies are not used. This value is 1 by default.",
          "type": "int"
        },
        "use_initial_mapping": {
          "description": "A boolean flag that, if set to True (the default is False), runs a heuristic algorithm to permute the Paulis in the cost operator to better fit the coupling map and the swap strategy. This is only needed when the optimization problem is sparse and when using swap strategies to transpile.",
          "type": "bool"
        }
      },
      "required": [
        "operator"
      ]
    },
    "return_values": {
      "$schema": "https://json-schema.org/draft/2019-09/schema",
      "properties": {
        "optimizer_time": {
          "description": "The total time taken by the optimizer.",
          "type": "float"
        },
        "optimal_value": {
          "description": "The smallest value found during the optimization. Equal to the ``eigenvalue`` attribute.",
          "type": "float"
        },
        "optimal_point": {
          "description": "The optimal parameter values found during the optimization.",
          "type": "np.ndarray"
        },
        "optimal_parameters": {
          "description": "Not supported at the moment, therefore ``None``.",
          "type": "NoneType"
        },
        "cost_function_evals": {
          "description": "The number of cost function (energy) evaluations.",
          "type": "int"
        },
        "eigenstate": {
          "description": "The square root of sampling probabilities for each computational basis state of the circuit with optimal parameters.",
          "type": "dict"
        },
        "eigenvalue": {
          "description": "The estimated smallest eigenvalue.",
          "type": "complex"
        },
        "aux_operator_eigenvalues": {
          "description": "The expectation values of the auxiliary operators at the optimal state.",
          "type": "np.ndarray"
        },
        "optimizer_history": {
          "description": "A dictionary containing information about the optimization process: the value objective function, parameters, and a timestamp.",
          "type": "Dict[str, Any]"
        },
        "inputs": {
          "description": "A dictionary of the serialized input keyword arguments.",
          "type": "Dict[str, Any]"
        }
      }
    }
  }
}
